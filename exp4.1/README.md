# Experiment 4.1

题解作者：MHY

本题由[leetcode#928](https://leetcode-cn.com/problems/minimize-malware-spread-ii/ "leetcode真是个好东西！")改编而来。

### 实验目的

本实验的主要目的是：
* 增进各位对图数据结构的理解；
* 熟练掌握图的搜索；
* 锻炼各位同学的转化问题、解决问题的能力。

### 思路详解
我们已经提示过各位：本题是个搜索题，不需要用什么Tarjan算法。所以我们来看一下本题应该怎么搜索。首先来分析题目：

题目已知条件：每一个病毒源都会把病毒扩散到它所在的整个连通片。所以我们应该对每一个病毒源进行遍历，了解它能够把病毒传染到哪些节点上。

但是上述思路没有考虑我们要完成什么任务。我们的任务是：删除一个节点到所有与之相连的节点的连接，以减少病毒的传播。所以，对每一个病毒源，只有被那个病毒源“唯一控制”的节点才是有意义的。其中，”唯一控制“的定义是，删除了这个病毒源，其他的病毒就不能扩散到此位置。因此，我们在搜索的时候需要注意：在对每一个病毒源进行搜索时，不要管其他病毒源的”私有财产“。在搜索时，遇到其他的病毒源就要停止，只管自己能直接到达的那一部分。最后，划分完每个病毒源的”势力范围“之后，去掉”公有部分“就是私有部分，找私有部分最多的病毒源干掉即可。

所以我的思路是：
* 对每一个病毒源进行深度优先遍历。（用DFS的原因是DFS可以用递归，比较好写）
  遍历时，对于与当前结点相邻的每一个点：
  * 如果此节点是病毒源：
    * 直接返回，不能干涉他源内政。
  * 如果此节点的被遍历次数是0：
  说明这个节点暂时还没有它的感染源。所以我们要给这个节点确定其支配关系。要进行如下操作：
    * 给这个节点标记它的感染源
    * 被遍历次数+1
    * 从此节点继续遍历
  * 如果此节点的被遍历次数是1：
  说明这个节点会成为一个公共节点。所以我们要把遍历次数改为2,以声明这个节点是公共的。操作如下：
    * 被遍历次数+1
    * 从此节点继续遍历，以标记所有的公共节点。
  * 如果此节点的被遍历次数是2：
  既然当前节点已被声明为公共节点，那么所有与它相连的节点都已经成为了公共节点（看一下上面的操作）。所以再继续遍历没有意义，我们应该：
    * 不继续遍历，直接return返回上层递归函数。
* 对每一个被遍历次数为1的点，统计其病毒源。找出私有财产最多的病毒源。
  * 如果没有被遍历次数为1的点，输出-1.
  * 如果有多个点私有财产数量相同，输出最小的。

至此，本题解释完毕。

### 花絮

很凑巧的是，超炮3的部分剧情和本题的背景不谋而合：

<div align="center">
    <img src="readme-pics/Shokuhou-1.jpg"/>
    <img src="readme-pics/Shokuhou-2.jpg"/>
</div>

<p align="center" style='font-size:12px;color:gray'>我们的食蜂同学遇到的是本题的一个特例——只有一个病毒源。</p>


某日，四个~~被食蜂同学控制了的~~助教正在开会讨论图论部分应该出什么题。助教们翻了科大编的教材、严蔚敏书和大黑皮《算法导论》，却一直找不到合适的题。

后来某助教提议：不如去Leetcode找找！Leetcode上[标着图论标签](https://leetcode-cn.com/tag/graph/ "Leetcode真是个好东西！")的有37道题，找出一道能用的应该不难。不过难度一定要选“困难”的，因为给三周时间，思考时间比较多，所以不能降低思维难度，得稍微拉开一点区分度。区分度可以是通过的测点个数，也可以是做题花费的时间。

所以看了#765、#839、#928和#996。
* #765、#839和图论关系并不密切，所以排除；
* #996没有有效算法，时间复杂度过高，所以排除；
* 还有一些其他题目需要用动态规划、贪心算法等知识，所以也排除。
* 所以最后就选了#928。

下面是一些好玩的环节：
* 有人问“为啥邻接矩阵的对角线是1”，原因其实是，Leetcode#928就是这么规定的...不过按“本机可以用127.0.0.1与自身相连”也可以说得过去，所以就维持原状了。
* 原题并没有“如果删除任何一个节点后的最终感染数量与不删除节点的最终感染数量相同，请输出-1”这句话。助教在做题的时候，被这个点坑了一段时间：因为按照原题的定义，如果删除任何一个节点后的最终感染数量与不删除节点的最终感染数量相同，应该输出所有感染源里编号最小的节点。但是助教在写的时候，记录结果的变量没有初始化，就一直卡wrong answer，于是后来就把这个规定加上了。
  
最后就是翻车环节：

因为Leetcode只需要完成函数就行了，且函数传入的是一个邻接矩阵，所以输入也是维持原状采用输入邻接矩阵的方式。结果忘了这么一件事：矩阵的规模太大会使输入时间占比过高，导致用getchar可以快好几倍...
这确实是我们的失误，助教还是太naive了啊......

