# 实验4.1 保护御坂网络
by 穿越了的助教们
### 实验背景
御坂网络的某些节点遭到了黑客入侵，黑客在这些节点上放置了病毒程序。病毒的工作方式是这样的：病毒会自动感染与这个节点直接相连的所有节点。且病毒会持续扩散传播，直到没有更多的节点可以被这种方式感染。

作为御坂网络的核心，最后之作也受到了严重的黑客攻击，很 多功能已经不能正常运转。现在她能做的只有：抢在病毒开始传播之前关闭一个已被入侵的节点（关闭某个节点之后，这个节点会断开所有连接，病毒无法入侵），随后让自己进入休眠模式，防止自己被黑客入侵后引起更大的混乱。

“所以我现在应该关闭哪个节点，才能让整个网络的损失降到最低呢？”御坂御坂焦急的说道。

### 不说人话的部分
我们定义点集在无向图中的连通分量为：点集中所有的点所在的连通分量的并集。
现有图$𝐺(𝑉,𝐸), 𝑉^{'}\subsetneqq𝑉$。现求点$𝑣\in𝑉^′$，使得$𝑉^′−𝑣$在$𝐺−𝑣$中的联通分量所含点数最少。


### 说人话的部分
1. 输入： 若干行。
  a. 第1行：网络节点数量$𝑛$，即$𝐶𝑎𝑟𝑑(𝑉)$。本行以回车结束。
  b. 第2~$n+1$行：图的邻接矩阵。矩阵的每列用空格隔开，每行用回车隔开。
  c. 第$n+2$行：初次被感染的节点数量$𝑚$，即$𝐶𝑎𝑟𝑑(𝑉^′)$。本行以回车结束。
  d. 第$n+3$行：初次被感染的节点，即$𝑉^′$。不同的节点用空格隔开。本行以回车结束。

2. 输出：
  a. 只有一行，代表被删除的节点（即$𝑣$）。输出完毕后不要加回车。
  b. 如果删除任何一个节点后的最终感染数量与不删除节点的最终感染数量相同，请输出$-1$。
  c. 如果多个节点都满足条件（即删除两个不同节点，最后的结果都一样），请输出编号最小的节点。
  d. b的优先级高于c。

3. 提示与要求：
   a. 节点编号从 0 开始；
   b. 输入的图未必是连通图；
   c. 设输入的邻接矩阵为$𝐺$。我们保证：
     * $𝐺$是对称矩阵。
     * $𝐺[𝑖][𝑗]$只会为 $0$ 或 $1$ ，且$𝐺[𝑖][𝑖]=1$。这么做的原因是本机与自己是直接相连的；
     * 被感染的节点编号$<𝑛$。编号的输入是无序的；
     * 不会一上来就感染所有节点，即保证$𝑚<𝑛, 𝑉^{'}\subsetneqq𝑉$。

   d. 下周（ 15 号之后）我们还会放一道题，两道题的截止日期相同，所以请合理安排时间。这两道题中，由于本题难度较大（准确地说，是比较绕）两道题的分值占比会进行动态分配。具体占比暂时不会公布，但是可以确定的是，4.1 ac 的人越多，占比越高。
   e. 通过测点数量与最终得分的映射关系暂未确定，之后会发布。
   
   f. **我们按过的测试点数量给分，而不是按用时、尝试次数、board排名等给分。但我们鼓励各位写出简洁、优美、高效的代码。**
   g. **本次实验不准使用STL。**

### 数据规模说明
50%的测点满足： $0<m<n≤20$。

70%的测点满足： $0<m<n≤500$。

100%的测点满足： $0<m<n≤1500$。

注：

* 我们当然想把数据规模设置为 $0<m<n≤9969$，但是如果那样的话规模就太大了，oj上会超时。
* 经过测试，在$n=1500$的条件下，预期解用时在200ms左右（输入采用scanf，没用iostream和STL），本用时仅供参考。如果您超时，请考虑一下算法时间复杂度的问题。
* 如果您的方法过于暴力，建议使用getchar读取邻接矩阵，缩短读入时间。


### 输入输出样例
| 输入 | 输出 | 解释 |
|:-|:-|:-|
|3<br>1 1 0<br>1 1 1<br>0 1 1<br>2<br>0 1 | 1 | 如果删掉0，1的病毒还会继续扩散到2；<br>如果删掉1，2就不会被感染。|
|4<br>1 1 1 0<br>1 1 0 1<br>1 0 1 1<br>0 1 1 1<br>2<br>2 1 | -1 | 无论删掉1还是2，节点0和3最后都会被感染，因此输出-1.|


### 提交方式
在oj.ustc.edu.cn上提交。